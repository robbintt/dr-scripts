=begin
  Documentation: https://elanthipedia.play.net/Lich_script_repository#steal
=end

custom_require.call(%w[common common-arcana common-items common-travel drinfomon equipmanager])

class Steal
  include DRC
  include DRCA
  include DRCI
  include DRCT

  def setup(settings)
    start_script('jail-buddy') unless Script.running?('jail-buddy')

    # Make sure that our Thievery ranks are up-to-date - avoid using stale data for new characters who joined the guild
    bput('exp thievery', 'EXP HELP') if DRSkill.getrank('Thievery').zero?

    UserVars.stealing_timers ||= {}

    @stealing_options = get_data('stealing').stealing_options.reject { |target| settings.dont_steal_list.include?(target['id'].to_i) }
    @stealing_bag = settings.stealing_bag
    hometown_data = get_data('town')[settings.hometown]
    @bin_id = hometown_data['thief_bin'] && hometown_data['thief_bin']['id']
    @stealing_towns = settings.stealing_towns
    @bin_stolen = settings.bin_stolen
    if @bin_stolen && !@bin_id
      echo("*** Binning is not yet supported in #{settings.hometown}")
      @bin_stolen = false
    end
    @hide_to_steal = settings.hide_to_steal
    @stealing_low_acceptable_count = settings.stealing_low_acceptable_count
    @stealing_high_acceptable_count = settings.stealing_high_acceptable_count
    @steal_past_mindlock = settings.steal_past_mindlock
    @slow_bin_speed = settings.slow_bin_speed

    @difficulty_keys = %w[exceptionally very rather acceptable poorly vpoorly nearly trivial]

    @bin_items = []
  end

  def initialize
    arg_definitions = [
      [],
      [
        { name: 'item', regex: /\w+|\w+\s\w+/, variable: true, description: 'item to steal' },
        { name: 'container', regex: /.+/i, variable: true, description: 'Where the item is to steal e.g in catalog, on counter' }
      ]
    ]

    args = parse_args(arg_definitions)

    settings = get_settings
    setup(settings)
    targets = find_targets(args.item, args.container)
    npcs = settings.npc_stealing_attempt_count > 0 ? find_npcs : []
    if targets.empty? && npcs.empty?
      echo '***NO VALID TARGETS FOUND***'
      return
    end

    stealing_buffs = settings.stealing_buffs
    do_buff(stealing_buffs, settings)

    @equipment_manager = EquipmentManager.new
    @equipment_manager.empty_hands
    @equipment_manager.wear_equipment_set?('stealing')
    if left_hand || right_hand
      echo '***ITEMS ARE STILL IN HANDS, EXITING***'
      @equipment_manager.wear_equipment_set?('standard')
      return
    end
    start_script('performance', ['noclean']) unless settings.hide_to_steal
    npcs.each { |npc| steal_from_npc(npc, settings.npc_stealing_attempt_count) }
    targets.each { |target| steal(target) }
    @equipment_manager.wear_equipment_set?('standard')

    if stealing_buffs['khri']
      stealing_buffs['khri'].each { |name| fput("khri stop #{name}") }
    end

    bin_items
  end

  def find_npcs
    %w[beggar minstrel veteran].select { |npc| ready_to_steal?(npc) }
  end

  def steal_from_npc(npc, count)
    return if stop_stealing?

    echo("***STATUS*** Searching for: #{npc}") if UserVars.thievery_debug
    wait_for_script_to_complete('find', [npc])
    count.times do
      break unless DRRoom.npcs.include?(npc)
      echo("***STATUS*** Stealing from: #{npc}") if UserVars.thievery_debug
      hide? if @hide_to_steal
      fput("steal #{npc}")
      waitrt?
    end
    cooldown(npc, 60)
  end

  def ready_to_steal?(index)
    UserVars.stealing_timers[index].nil? || Time.now > UserVars.stealing_timers[index]
  end

  def cooldown(name, minutes)
    UserVars.stealing_timers[name] = Time.now + 60 * minutes
    echo("putting target on cooldown: #{name}") if UserVars.thievery_debug
  end

  def do_buff(buffs, settings)
    buffs['spells'].each do |spell|
      check_discern(spell, settings) if spell['use_auto_mana']
      cast_spell(spell, settings)
    end

    buffs['khri']
      .map { |name| "Khri #{name}" }
      .each { |name| activate_khri?(settings.kneel_khri, name) }
  end

  def bin_items
    return if @bin_items.empty?
    return unless walk_to_bin?

    stow_hands
    @bin_items.each do |item|
      if @slow_bin_speed
        bput("get #{item} from my #{@stealing_bag}", 'You get')
        bput("put #{item} in bin", 'nods toward you as your .* falls into the .* bin')
      else
        put("get #{item} from my #{@stealing_bag}")
        put("put #{item} in bin")
      end
      pause 0.25
    end
  end

  def walk_to_bin?
    @bin_id && walk_to(@bin_id)
  end

  def find_targets(item, container)
    if item && container
      [build_target_data(item, container)]
    else
      find_all_targets
    end
  end

  def build_target_data(item, container)
    tracked_items_in_shop = @stealing_options.select { |x| x['room'] == Room.current.id }
    data = tracked_items_in_shop.find { |x| x['item'] == item && x['item_in'] =~ /#{container}/ }

    data || build_new(item, container)
  end

  def build_new(item, container)
    town = nil
    if @stealing_towns.empty?
      echo('*** You have no stealing_towns set; cannot add a new item.')
    elsif @stealing_towns.size == 1
      town = @stealing_towns.first
      echo('***This appears to be a new item.')
      echo("Note: the stealing town is set to '#{town}'.")
      echo(';send yes  if this is a new item and this town is correct, or ;send no  to cancel')
      loop do
        line = get
        exit if line =~ /^no/i
        break if line =~ /^yes/i
      end
    else
      echo('***This appears to be a new item.')
      echo(';send the number of the town in the list below (e.g. ;send 1 ) if this is correct, or ;send no  to cancel.')
      @stealing_towns.each_with_index { |town, i| echo("  #{i + 1} :  #{town}") }
      echo('If the desired town does not appear in this list, add it to your stealing_towns and try again.')
      loop do
        line = get
        exit if line =~ /^no/i
        next unless line =~ /^\d+$/
        index = line.to_i
        exit unless index > 0
        town = @stealing_towns[index - 1]
        break
      end
    end

    exit if town.nil?

    {
      'new' => true, 'room' => Room.current.id, 'town' => town,
      'item' => item, 'item_in' => container, 'pawnable' => false,
      'id' => @stealing_options.map { |x| x['id'].to_i }.max + 1
    }
  end

  def find_all_targets
    thievery_skill = DRSkill.getrank('Thievery')

    targets = [[], [], []]

    @stealing_options
      .select { |data| data['guilds'].nil? || data['guilds'].include?(DRStats.guild) }
      .select { |data| @stealing_towns.include?(data['town']) }
      .select { |data| ready_to_steal?(data['room']) }
      .each { |data| thievery_is_appropriate(data, thievery_skill, targets) }

    per_room_target = {}

    targets.each do |set|
      set.each do |data|
        per_room_target[data['room']] ||= data
      end
    end

    per_room_target.values
  end

  def thievery_is_appropriate(data, skill, targets)
    upper_keys = @difficulty_keys[0..2]

    if data['acceptable_min'] && data['acceptable_min'] <= skill && data['acceptable_max'] >= skill
      if (data['acceptable_max'] + data['acceptable_min']) / 2 <= skill
        targets[0] << data
      else
        targets[1] << data
      end
      return
    end

    return if data['trivial_min'] && data['trivial_min'] <= skill

    upper_keys
      .reverse
      .select { |diff| data["#{diff}_min"] }
      .each_with_index do |diff, index|
        if (data["#{diff}_min"] + data["#{diff}_max"]) / 2 + (skill * 0.10 * index) < skill
          targets[1] << data
          return
        end
      end

    if data['acceptable_max'] && data['acceptable_max'] + 1 == skill && data['poorly_min'] != skill
      targets[0] << data
      return
    end
    if data['acceptable_min'] && data['acceptable_min'] - 1 == skill && data['rather_max'] != skill
      targets[1] << data
      return
    end

    if data['acceptable_max'] && skill > data['acceptable_max']
      targets[2] << data
    end
  end

  def bin_item(item)
    waitrt?
    if XMLData.room_title == '[[A Junk Yard]]'
      # Stop binning future items and drop this item
      @bin_stolen = false
      # Dispose of one extra item to stay under the item limit
      last_stolen = @bin_items.pop
      bput("get my #{last_stolen} from my #{@stealing_bag}", 'You get', 'What were you') if last_stolen
      dispose_trash(last_stolen)
    end

    keep_item = @bin_stolen

    if keep_item
      if put_item?(item)
        @bin_items.push(item)
      else
        keep_item = false
      end
    end

    drop_item(item) unless keep_item

    move('go portal') if XMLData.room_title == '[[A Junk Yard]]'
    waitrt?
  end

  def put_item?(item)
    case bput("put my #{item} in my #{@stealing_bag}", 'What were you', 'You put', "You can't do that", 'no matter how you arrange it', 'The .* is *.* too \w+ to fit in', 'There isn\'t any more room', 'perhaps try doing that again')
    when 'perhaps try doing that again'
      return put_item?(item)
    when 'You put'
      return true
    when 'What were you'
      handheld = held_item(item)
      drop_item(held_item(item)) if handheld
      return false
    end

    false
  end

  def drop_item(item)
    case bput("drop my #{item}", 'You drop', 'You spread', 'You wince', 'would damage it', 'smashing it to bits', 'Something appears different about', 'What were you')
    when 'would damage it', 'Something appears different about'
      drop_item(item)
    when 'What were you'
      handheld = held_item(item)
      return drop_item(held_item(item)) if handheld
    end
  end
  
  def held_item(item)
    [DRC.right_hand, DRC.left_hand].each do |hand_item|
      hand_item.split.each do |item_word|
        return hand_item if item.include?(item_word)
      end
    end
    
    return nil
  end

  def update_target(target, difficulty)
    skill = DRSkill.getrank('Thievery')
    return if skill <= 0

    return if target["#{difficulty}_min"] && target["#{difficulty}_max"] && skill >= target["#{difficulty}_min"] && skill <= target["#{difficulty}_max"]

    echo("update required for :#{target}") if UserVars.thievery_debug

    lower_keys = @difficulty_keys[0..@difficulty_keys.index(difficulty)] - [difficulty]
    upper_keys = @difficulty_keys[@difficulty_keys.index(difficulty) + 1..-1]

    update = target['new'] ? target.dup : {}

    if target["#{difficulty}_min"].nil? || skill < target["#{difficulty}_min"]
      update["#{difficulty}_min"] = skill
      lower_keys.each do |diff|
        update["#{diff}_min"] = skill - 1 if target["#{diff}_min"] && target["#{diff}_min"] >= skill
        update["#{diff}_max"] = skill - 1 if target["#{diff}_max"] && target["#{diff}_max"] >= skill
      end
    end
    if target["#{difficulty}_max"].nil? || skill > target["#{difficulty}_max"]
      update["#{difficulty}_max"] = skill
      upper_keys.each do |diff|
        update["#{diff}_min"] = skill + 1 if target["#{diff}_min"] && target["#{diff}_min"] <= skill
        update["#{diff}_max"] = skill + 1 if target["#{diff}_max"] && target["#{diff}_max"] <= skill
      end
    end

    update['trivial_max'] = 1750 if update['trivial_max']

    echo("update:#{update}") if UserVars.thievery_debug

    @stealing_options.each { |data| data.merge!(update) if data['id'] == target['id'] }
    submit_thieving_update(target['id'], update)
  end

  def make_grab?(target, count)
    hide? if @hide_to_steal
    item = target['item']
    in_message = target['item_in']
    waitrt?
    count += 1
    case bput("steal #{item} #{in_message}",
              'You learned exceptionally well from this nearly impossible theft',
              'You learned very well from this extremely difficult theft',
              'You learned rather well from this difficult theft',
              'You learned acceptably from this theft',
              "You don't feel you learned anything useful from this trivial theft",
              'You learned somewhat poorly from this simple theft',
              'You learned very poorly from this very simple theft',
              'You learned quite badly from this nearly trivial theft',
              'realize that you are being watched and should back off',
              'but decide you have too many outstanding fines as is',
              'you decide to wait a while before trying again',
              "You haven't picked something to steal",
              "You can't steal that",
              'Roundtime')
    when /this trivial theft/
      update_target(target, 'trivial') if count == 1
      bin_item(target['item'])
    when /nearly trivial theft/
      update_target(target, 'nearly') if count == 1
      bin_item(target['item'])
      steal(target, count) if count < 4
    when /very poorly/
      update_target(target, 'vpoorly') if count == 1
      bin_item(target['item'])
      steal(target, count) if count < 3
    when /somewhat poorly/
      update_target(target, 'poorly') if count == 1
      bin_item(target['item'])
      steal(target, count) if count < 3
    when /learned acceptably/
      update_target(target, 'acceptable') if count == 1
      bin_item(target['item'])
      if (target['acceptable_max'] + target['acceptable_min']) / 2 <= DRSkill.getrank('Thievery')
        steal(target, count) if count < @stealing_low_acceptable_count
      elsif count < @stealing_high_acceptable_count
        steal(target, count)
      end
    when /learned rather well/
      update_target(target, 'rather') if count == 1
      bin_item(target['item'])
    when /learned very well/
      update_target(target, 'very') if count == 1
      bin_item(target['item'])
    when /learned exceptionally/
      update_target(target, 'exceptionally') if count == 1
      bin_item(target['item'])
    when /but decide you have too many outstanding fines as is/
      beep
      echo('Too many fines, cannot steal anything')
      return false
    when /You haven't picked something to steal/
      beep
      echo('Can not steal this item')
      return false
    when /realize that you are being watched and should back off|you decide to wait a while before trying again/
      beep
      echo('Temporarily cannot steal from this room')
      return false
    else
      bin_item(target['item'])
      beep
      echo('new learning message: PLEASE SUBMIT')
    end

    true
  end

  def steal(target, count = 0)
    return if stop_stealing?

    if walk_to(target['room'], false)
      cooldown(target['room'], 60)
      waitrt?
      @equipment_manager.empty_hands
      return unless make_grab?(target, count)
    else
      cooldown(target['room'], 10)
    end
  end

  def stop_stealing?
    DRSkill.getxp('Thievery') >= 30 && !@steal_past_mindlock
  end
end

before_dying do
  stop_script('performance') if Script.running?('performance')
end
# Call this last to avoid the need for forward declarations
Steal.new
